# 백트래킹

## 소개

8퀸 문제

### 백트래킹(Backtracking) 기법

- 해를 찾는 도중에 '막히면' (즉, 해가 아니면) 되돌아가서 다시 해를 찾아가는 기법
- 최적화(Optimization) 문제와 결정(Decision) 문제를 해결할 수 있음
- 결정 문제: 문제의 조건을 만족하는 해가 존재하는지의 여부를 'yes' 또는 'no'로 답하는 문제

### 백트래킹

초기 상태에서 목표 상태로 가는 경로를 탐색하는 기법

- 여러 가지 선택지(옵션)들이 존재하는 상황에서 한가지 선택
- 선택이 이루어지면 새로운 선택지들의 집합 생성
- 선택을 반복하면서 최종 상태에 도달
  - 올바른 선택을 계속하면 목표 상태(Goal state)에 도달

트리의 루트로부터 당첨이라는 단말 노드까지 가는 경로 찾기

1. 어떤 경로를 선택해야 당첨 단말 노드까지 갈 수 있는지 알 수는 없음
2. 당첨 노드까지 가기 위한 모든 경로에 대해서 탐색

당첨 단말 노드 찾기

1. 루트에서 갈 수 있는 노드 선택
2. 꽝 노드까지 도달하면 최근의 선택으로 되돌아와서 다시 시작
3. 더 이상의 선택지가 없다면 이전의 선택지로 돌아가서 다른 선택
4. 루트까지 돌아갔을 경우 더 이상 선택지가 없다면 찾는 답이 없음

### 상태 공간 트리

- 해를 찾기 위한 선택의 과정을 트리로 표현
- 트리의 내부 노드는 최종 상태로 가는 중간 상태를 나타냄
- 트리의 단말 노드는 하나의 후보해에 대한 최종 상태가 됨
- 상태 공간 트리를 탐색하는 것은 모든 후보해들을 탐색하는 것
- 트리를 깊이 우선 탐색하는 방법이 백트래킹 알고리즘의 기본 형태

### 백트래킹과 깊이 우선 탐색과의 차이

| 백트래킹 기법                                                | 깊이 우선 탐색                                               |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써  시도의 횟수를 줄임(Prunning 가지치기) | 모든 경로 추적                                               |
| 백트래킹은 가지치기로 불필요한 경로를 조기에 차단            | 경우의 수가 너무 많은 경우 처리 불가능                       |
| 백트래킹 알고리즘 적용으로 일반적으로 경우의 수가 줄어들게 되어 처리 가능 | N!가지의 경우의 수를 가진 문제는 경우의 수가 너무 많아져서 처리 불가능 |
| 최악의 경우 여전히 지수 함수 시간(Exponential Time)을 필요로 하므로 처리 불가능 |                                                              |

### 깊이 우선 검색 방법 사용

해가 될 가능성이 전혀 없는 노드의 후손노드(Descendant)들도 모두 검색해야 하므로 비효율적임

### 백트래킹 기법

모든 후보해를 검사하지 않음

- 어떤 노드의 유망성 점검 후 유망(Promising)하지 않다고 결정되면 해당 노드의 부모로 되돌아가(Backtracking) 다음 자식 노드로 감
- 어떤 노드를 방문했을 때 해당 노드를 포함한 경로의 해답 여부
  - 해답이 될 수 없을 경우 해당 노드는 유망하지 않다고 함
  - 해답의 가능성이 있을 경우 유망하다고 함
- 가지치기(Pruning) - 유망하지 않는 노드가 포함되는 경로는 더 이상 고려하지 않음

### 백트래킹을 이용한 알고리즘의 진행 절차

1. 상태 공간 트리에 대한 깊이 우선 탐색 실시
2. 방문하는 노드가 유망한지 여부 점검
   1. 노드의 유망성 판단 방법은 해를 찾으려는 문제에 따라 달라짐
3. 만일 선택한 노드가 유망하지 않을 경우, 해당 노드의 부모 노드로 돌아가서 검색 계속 진행

## 4퀸 문제

~~~python
def checknode(v):
    if promising(V):
        if there is a solution at v:
            write the solution
        else:
            for u in each child of v:
                checknode(u)
~~~

