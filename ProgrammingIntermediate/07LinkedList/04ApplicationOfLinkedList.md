# Linked List의 활용

## List를 이용한 Stack

### 스택의 원소: 리스트의 노드

- 스택 내의 순서는 리스트의 링크를 통해 연결됨
- Push: 리스트의 첫 번째에 노드 삽입
- Pop: 리스트의 첫 번째 노드 반환/ 삭제

### 변수 Top

- 리스트의 마지막 노드를 가리키는 벼수
- 초기 상태: Top = None

## List를 이용한 Stack의 연산

### 리스트를 이용해 Push와 Pop 연산 구현

1. None 값을 가지는 노드를 만들어 스택 초기화(Top = None)
2. 원소 A 삽입: Push(A) (Top -> A 주소)
3. 원소 B 삽입: Push(B) (Top -> B 주소)
4. 원소 C 삽입: Push(C) (Top -> C 주소)
5. 원소 반환: Pop (Top -> B 주소)

## List를 이용한 Stack의 구현

~~~python
def push(i):
    global top
    top = Node(i, top)
def pop():
    global top
    
    if top == None:
        print("error")
    else:
        data = top.data
        top = top.link
        return data
~~~

## 우선순위 Queue

### 우선순위 큐의 구현과 기본 연산

우선순위 큐의 구현

- 연결 리스트를 이용한 우선순위 큐

우선순위 큐의 기본 연산

- 삽입: enQueue
- 삭제: deQueue

### 순차 리스트를 이용한 우선순위 큐 구현

- 순차 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 우선순위를 비교하여 적절한 위치에 삽입하는 구조
- 가장 앞에 최고 우선순위의 원소가 위치하게 됨
- 배열을 사용하므로, 삽입이나 삭제 연산이 일어날 때 원소의 재배치가 발생함.
- 이에 소요되는 시간이나 메모리 낭비가 큼

### 연결 리스트를 이용한 우선순위 Queue 구현

- 연결 리스트를 이용하여 자료 저장
- 원소를 삽입하는 과정에서 리스트 내 노드의 원소들과 비교하여 적절한 위치에 노드를 삽입하는 구조
- 리스트의 가장 앞쪽에 최고 우선순위가 위치하게 됨

배열 대비 장점

- 삽입/삭제 연산 이후 원소의 재배치가 필요 없음
- 메모리의 효율적인 사용이 가능함

































