# 메모이제이션과 동적 계획법

### 메모이제이션(Memoization)

- 컴퓨터 프로그램 실행 시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
- 동적 계획법의 핵심이 되는 기술

### 피보나치 수를 구하는 알고리즘

 fibo1(n)의 값을 계산하자마자 저장하면, 실행시간을 $$ O(n) $$으로 줄일 수 있음

Memoization  방법을 적용한 알고리즘

~~~python
# memo 리스트를 할당하고, 모두 0으로 초기화 한다.
# memo[0]을 0으로 memo[1]는 1로 초기화 한다.
def fibo1(n):
    if n >= 2 and memo[0] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]
~~~

피보나치 함수의 메모이제이션 적용

- 추가적인 메모리 공간 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용하게 되고 실행 속도 저하 또는 오버플로우 발생 가능
  - 실행 속도 저하 또는 오버플로우 발생 문제에 대한 해결책은?

## 소개

### 동적 계획(Dynamic Programming) 알고리즘

- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
  - 최적화 문제 - 최적(최대값이나 최소값 같은) 값을 구하는 문제
    - 여러 개가 있을 수 있음
    -  The를 구하는 것이 아니라 an을 구하는 것

1. 작은 부분 문제들의 해들을 구함
2. 해를 이용하여 보다 큰 크기의 부분 문제들 해결
3. 최종적으로 원래 주어진 문제 해결

### 동적 계획법(DP)

- 완전검색을 좀 더 효율적으로 하는 방법
- Recursive + Memoization
- 점화식을 찾으면 가능

## 적용 조건

### 동적 계획법 적용 문제의 요건

1. 중복 부분문제 구조(Overlapping subproblems)
   1. 동적 계획법은 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해(Optimal Solution)를 이용하여 순환적으로 큰 문제 해결
      1. 순환적인 관계(Recurrence relation)를 명시적으로 표현하기 위해서 수학적 도구인 점화식 사용
   2. 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복해서 사용
   3. 동적 계획법에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(Table)에 저장
   4. 이미 해결된 문제의 해들이 다시 필요할 때마다 table을 참조해서 중복된 계산 피함
2. 최적 부분 문제 구조(Optimal Substructure)
   1. 동적 계획법이 어느 최적화 문제에나 적용되지 않음 
      1. 주어진 문제가 최적화의 원칙(Principle of Optimality)을 만족해야만 동적 계획법을 효율적으로 적용 가능
   2. 최적화의 원칙
      1. 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 함
      2. 동적 계획법의 방법 자체가 큰 문제의 최적 해를 작은 문제의 최적 해 들을 이용하여 구함
      3. 만약 큰 문제의 최적 해가 작은 문제들의 최적 해들로 구성되지 않는다면 해당 문제는 동적 계획법 적용 불가능

최장경로 문제는 동적 계획법으로 해결 불가능

| 분할 정복                         | 동적 계획법                                             |
| --------------------------------- | ------------------------------------------------------- |
| 큰 문제를 작은 부분 문제들로 분할 | 부분문제들의 해는 더 작은 부분 문제들의 해를 공유       |
| 부분문제를 재귀적으로 해결        | 모든 부분문제를 한 번만 계산하고 결과를 저장하고 재사용 |
| 부분문제의 해를 결합(Combine)     |                                                         |

- 동적 계획법에는 부분문제들 사이에 의존적 관계가 존재
- 관계는 문제에 따라 다르고 대부분의 경우 뚜렷이 보이지 않아서 함축적인 순서(Implicit order)라고 함
- 분할 정복은 하향식 방법으로 동적 계획법은 상향식 방법으로 접근

## 적용하기

### 동적 계획법을 적용하기 위한 방법

1. 최적해 구조의 특성 파악하기
   1. 문제를 부분 문제로 나눔
2. 최적해의 값을 재귀적으로 정의하기
   1. 부분 문제의 최적해 값에 기반하여 문제의 최적해 값을 정의
3. 상향식 방법으로 최적해의 값을 계산하기
   1. 가장 작은 부분 문제부터 해를 구한 뒤 테이블에 저장
   2. 테이블에 저장되어 있는 부분 문제의 해를 이용하여, 점차 상위 부분 문제의 최적해를 구함(상향식 방법)

### 피보나치 수 DP 적용

피보나치 수는 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분구조로 이루어져 있음

1. 문제를 부분 문제로 분할
2. 점화식으로 정의
3. 가장 작은 부분 문제부터 해를 구함
   1. 결과는 테이블에 저장하고, 테이블에 저장된 부분 문제의 해를 이용하여 상위 문제의 해 구함

~~~python
def fibo_dp(n):
    f[0] = 0
    f[1] = 1
    for i in range(2, n + 1):
        f[i] = f[i - 1] + f[i - 2]
    return f[n]
~~~

### 피보나치 수 구하기 - 동적 계획법 알고리즘 분석

- 동적 계획법 알고리즘이 수행속도가 더 빠름
  - 재귀 알고리즘과는 달리 중복 계산이 없음
  - Memoization + 재귀 알고리즘은 함수 호출이 여전히 남아있음
  - 반복문을 사용하기 때문에 함수 호출이 발생하지 않음
- 계산하는 항(f[i])의 총 개수
  - T(n) = n + 1
  - f[0]부터 f[n]까지 단 한 번씩만  계산

