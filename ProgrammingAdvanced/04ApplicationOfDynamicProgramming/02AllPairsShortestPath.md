# 모든 쌍 최단 경로 문제

## 소개

### 최단 경로 문제

- 한 도시(정점)에서 다른 도시(정점)로 직항로가 없는 경우 가장 빨리 갈 수 있는 항로를 찾는 문제

### 모든 쌍 최단 경로 문제

- 모든 도시 사이에 가장 빨리 갈 수 있는 항로를 찾는 문제
- 가중치 포함, 방향성 그래프
  - 음의 가중치 허용, 가중치 합이 음인 싸이클은 허용하지 않음
- 최적화 문제(Optimization problem)
  - 주어진 문제에 대하여 하나 이상의 많은 해답이 존재할 때, 이 가운데에서 가장 최적인 해답(Optimal solution)을 찾아야 하는 문제

### 고지식한(Brute-force) 접근 방법

- 한 정점에서 다른 정점으로의 모든 경로의 길이를 구한 뒤, 그들 중에서 최소길이를 찾음
- 그래프가 n개의 정점을 가지고 있고, 완전그래프라고 가정할 경우
  - 한 정점 i에서 다른 정점 j로 가는 경로들을 다 모아 보면, 해당 경로들 중 정점 i, j를 제외한 나머지 모든 정점을 한번씩 꼭 거쳐서 가는 경로들도 포함되어 있는데, 그 경로들의 수만 우선 계산
  - i에서 출발하여 처음에 도착할 수 있는 정점의 가지 수는 n-2개
    - 하나를 선택하면, 그다음에 도착할 수 있는 정점의 가지 수는 n-3개 임
    - 계속하여 계산해 보면, 총 경로의 개수는 (n-2)(n-3) ... 1 = (n-2)!이 됨
  - 해당 경로의 개수만 보아도 지수보다 훨씬 크므로, 비효율적인 알고리즘

## 플로이드-워샬 알고리즘

### 모든 쌍 최단 경로 문제 해결을 위한 다른 방법

- 각 정점을 시작점으로 정해서 다익스트라(Dijkstra) 알고리즘 수행
- 시간복잡도는 리스트를 사용하면 $$O(n^3)$$이 됨
  - 모든 정점의 수 n X 다익스트라 알고리즘($$O(n^2)$$)
  - 다익스트라 알고리즘에서 리스트를 사용하면 $$O(n^2)$$, 힙을 사용하면 $$O(elogn)$$
  - n은 정점의 수, e는 간선의 수

| 워샬(Warshall)                                               | 플로이드(Floyd)                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 그래프에서 모든 쌍의 경로 존재 여부(transitive closure)를 찾아내는 동적 계획 알고리즘 제안 | 동적 계획 알고리즘을 변형하여 모든 쌍 최단 경로를 찾는 알고리즘 고안 |

플로이드 - 워샬 알고리즘 -> 모든 쌍 경로를 찾는 동적 계획 알고리즘

### 플로이드-워샬 알고리즘

- 시간복잡도 O(n^3)는 다익스트라 알고리즘을 리스트와 함께 사용할 때의 시간복잡도와 동일
- 매우 간단하며, 음의 가중치를 허용하지 않는 다익스트라 알고리즘을 사용하는 것보다 효율적
- 동적 계획법 적용

### 동적 계획 알고리즘을 모든 쌍 최단 경로 문제를 해결하려면!

- 부분 문제들을 찾아야 함
- 경유 가능한 점들을 하나씩 추가해 나가면서 최단 경로 구하기
  - 정점 1만 경유하는 정점으로 고려하고, 다음에는 정점 1과 2, 그 다음엔 정점 1, 2, 3을 경유하는 정점으로 고려
  - 정점 1~n까지의 모든 정점을 경유 가능한 정점들로 고려하면서, 모든 쌍 최단 경로를 구함
- 부분문제 정의: 단, 그래프의 정점을 각각 1, 2, 3, ..., n이라 함
  - $$D_{ij}^{k}$$ = 정점 {1, 2, ..., k}만을 경유 가능한 정점들로 고려하여, 정점 i로부터 정점 j까지의 모든 경로 중 최단 경로의 가중치 합

주의할 점: 경로가 정점 1에서 정점 k까지의 모든 정점들을 반드시 경유해야 하는 것을 의미하지 않음

- $$k \neq i$$, $$k \neq j$$이고, $$k=0$$인 경우, 정점 0은 그래프에 없으므로 어떤 정점도 경유하지 않는다는 것을 의미
  - $$D_{ij}^0$$은 그래프에 포함된 간선 $$(i, j)$$의 가중치
  - $$D_{ij}^1$$은 정점 $$i$$에서 정점 1을 경유하여 정점 $$j$$로 가는 경로와 정점 $$i$$에서 정점 $$j$$로 직접 가는 경로 중에서 짧은 거리
    - $$D_{ij}^1 = min(D_{i1}^0 + D_{1j}^0, D_{ij}^0)$$
  - 모든 정점 쌍 $$i$$와 $$j$$에 대하여 $$D_{ij}^1$$을 계산하는 것이 가장 작은 부분 문제들(단, $$i \neq 1$$, $$j \neq 1$$)
  - 정점 $$i$$에서 정점 2를 경유하여 정점 $$j$$로 가는 경로의 거리와 $$D_{ij}^1$$ 중에서 짧은 거리를 $$D_{ij}^2$$로 정함
    - 단, 정점 2를 경유하는 경로의 거리는 $$D_{i2}^1 + D_{2j}^1$$
- $$D_{ij}^2$$를 계산하려면 $$D_{ij}^1$$이 계산되어 있어야 함
- $$D_{ij}^2$$는 정점 1, 2를 경유 가능한 정점으로 고려한 최단 경로
- $$D_{ij}^k$$는 정점 i에서 정점 k를 경유하여 정점 j로 가는 경로의 거리와 $$D_{ij}^{k-1}$$ 중에서 짧은 것으로 정함
  - 단, 정점 k를 경유하는 경로의 거리는 $$D_{ik}^{k-1}$$ + $$D_{kj}^{k-1}$$이고 , $$i \neq k$$, $$j \neq k$$
- k가 1에서 n이 될 때까지 $$D_{ij}^k$$를 계산

### 플로이드-워샬 알고리즘

- $$D_{ij}^n$$을 계산해서 모든 정점을 경유 가능한 정점들로 고려된 모든 정점 쌍 $$i$$와 $$j$$의 최단 경로를 찾는 방식

### 모든 쌍 최단 경로 알고리즘

```python
# D[i][j]: i에서 j로 가는 최단 경로 가중치 합
# 최초 D[i][j]에는 간선(i, j)의 가중치 저장, i에서 j로 간선이 없으면 INF

def AllPairsShortest(D):
    for k in range(1, n+1):
        for i in range(1, n+1):
            if i == k: continue
            for j in range(1, n+1):
                if j == k or j == i: continue
                D[i][j] = min(D[i][k] + D[k][j], D[i][j])
```

### 시간복잡도

- 모든 쌍 최단 경로 알고리즘의 시간복잡도는 각 $$k$$에 대해서 모든 $$i, j$$ 쌍에 대해 계산
  - 총 $$n \times n \times n = n ^3$$회 계산이 이루어지고, 각 계산은 $$O(1)$$ 시간이 걸림
- 모든 쌍 최단 경로 알고리즘의 시간 복잡도는 $$O(n^3)$$

