# 메모이제이션과 동적 계획법

### 메모이제이션(Memoization)

- 컴퓨터 프로그램 실행 시 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 빠르게 하는 기술
- 동적 계획법의 핵심이 되는 기술

### 피보나치 수를 구하는 알고리즘

 fibo1(n)의 값을 계산하자마자 저장하면, 실행시간을 $$ O(n) $$으로 줄일 수 있음

Memoization  방법을 적용한 알고리즘

~~~python
# memo 리스트를 할당하고, 모두 0으로 초기화 한다.
# memo[0]을 0으로 memo[1]는 1로 초기화 한다.
def fibo1(n):
    if n >= 2 and memo[0] == 0:
        memo[n] = fibo1(n-1) + fibo1(n-2)
    return memo[n]
~~~

피보나치 함수의 메모이제이션 적용

- 추가적인 메모리 공간 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용하게 되고 실행 속도 저하 또는 오버플로우 발생 가능
  - 실행 속도 저하 또는 오버플로우 발생 문제에 대한 해결책은?

## 소개

### 동적 계획(Dynamic Programming) 알고리즘

- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘
  - 최적화 문제 - 최적(최대값이나 최소값 같은) 값을 구하는 문제
    - 여러 개가 있을 수 있음
    -  The를 구하는 것이 아니라 an을 구하는 것

1. 작은 부분 문제들의 해들을 구함
2. 해를 이용하여 보다 큰 크기의 부분 문제들 해결
3. 최종적으로 원래 주어진 문제 해결

### 동적 계획법(DP)

- 완전검색을 좀 더 효율적으로 하는 방법
- Recursive + Memoization
- 점화식을 찾으면 가능

## 적용 조건

### 동적 계획법 적용 문제의 요건

1. 중복 부분문제 구조(Overlapping subproblems)
   1. 동적 계획법은 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해(Optimal Solution)를 이용하여 순환적으로 큰 문제 해결
      1. 순환적인 관계(Recurrence relation)를 명시적으로 표현하기 위해서 수학적 도구인 점화식 사용
   2. 문제의 순환적인 성질 때문에 이전에 계산되어졌던 작은 문제의 해가 더 큰 문제의 해를 구할 때 중복해서 사용
   3. 동적 계획법에서는 이미 해결된 작은 문제들의 해들을 어떤 저장 공간(Table)에 저장
   4. 이미 해결된 문제의 해들이 다시 필요할 때마다 table을 참조해서 중복된 계산 피함
2. 최적 부분 문제 구조(Optimal Substructure)



